from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.admins.models.admin_model import Admin
from modules.admins.schemas.admin_schema import AdminCreate, AdminRead, AdminUpdate, AdminChangePassword
from modules.auth.admins import auth_admin
from modules.admins.services import admin_service
from modules.vendors.schemas.vendor_schema import VendorRead, VendorStatusUpdate
from modules.documents.schemas.document_schema import DocumentRead
from modules.documents.services import document_service


router = APIRouter(tags=["Admins"])

@router.post("/create", response_model=AdminRead)
def create_admin(admin: AdminCreate, db: Session = Depends(get_db)):
    new_admin = admin_service.create_admin(db, admin)
    if not new_admin:
        raise HTTPException(status_code=400, detail="Email already registered")
    return new_admin

@router.get("/me/{admin_id}", response_model=AdminRead)
def get_admin(
    admin_id: int,
    db: Session = Depends(get_db),
    current_admin: Admin = Depends(auth_admin.get_current_admin)
):
    admin = admin_service.get_admin(db, admin_id)
    if not admin:
        raise HTTPException(status_code=404, detail="Admin not found")
    return admin

@router.put("/edit/{admin_id}", response_model=AdminRead)
def update_admin(
    admin_id: int,
    admin_data: AdminUpdate,
    db: Session = Depends(get_db),
    current_admin: Admin= Depends(auth_admin.get_current_admin)
):
    updated_admin = admin_service.update_admin(db, admin_id, admin_data)
    if not updated_admin:
        raise HTTPException(status_code=404, detail="Admin not found")
    return updated_admin

@router.put("/change-password")
def update_admin_password(
    body: AdminChangePassword,
    db: Session = Depends(get_db),
    current_admin=Depends(auth_admin.get_current_admin)
):
    updated_admin, error = admin_service.change_admin_password(
        db,
        admin_id=current_admin.id,
        old_password=body.old_password,
        new_password=body.new_password
    )

    if error:
        raise HTTPException(status_code=400, detail=error)

    return {"message": "Password updated successfully"}


@router.put("/update-vendors/{vendor_id}", response_model=VendorRead)
def update_vendor_status(
    vendor_id: int,
    vendor_data: VendorStatusUpdate,
    db: Session = Depends(get_db),
    current_admin: Admin = Depends(auth_admin.get_current_admin)
):
    updated_vendor = admin_service.update_vendor_status(db, vendor_id, vendor_data)
    if not updated_vendor:
        raise HTTPException(status_code=404, detail="Vendor not found")
    return updated_vendor

@router.post("/chatbots/duplicate/{chatbot_id}")
def duplicate_chatbot(
    chatbot_id: int,
    db: Session = Depends(get_db),
    current_admin: Admin = Depends(auth_admin.get_current_admin)
):
    duplicated_chatbot = admin_service.duplicate_chatbot(db, chatbot_id)

    if not duplicated_chatbot:
        raise HTTPException(status_code=404, detail="Chatbot not found or cannot be duplicated")

    return duplicated_chatbot

@router.get("/documents", response_model=List[DocumentRead])
def get_documents(db: Session = Depends(get_db), current_admin: Admin = Depends(auth_admin.get_current_admin)):
    return document_service.get_documents(db)


@router.get("/most-users-by-vendors")
def most_users(db: Session = Depends(get_db), current_admin: Admin = Depends(auth_admin.get_current_admin)):
    return admin_service.get_vendor_with_most_users(db)

@router.get("/most-chatbots-by-vendors")
def most_chatbots(db: Session = Depends(get_db), current_admin: Admin = Depends(auth_admin.get_current_admin)):
    return admin_service.get_vendor_with_most_chatbots(db)

@router.get("/most-used-chatbot")
def most_used_chatbot(db: Session = Depends(get_db), current_admin: Admin = Depends(auth_admin.get_current_admin)):
    return admin_service.get_most_used_chatbot(db)

@router.get("/total-tokens/{vendor_id}")
def total_tokens(vendor_id: int, db: Session = Depends(get_db), current_admin: Admin = Depends(auth_admin.get_current_admin)):
    return admin_service.get_total_tokens_by_vendor(db, vendor_id)


from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.api_keys.services import api_service
from modules.api_keys.schemas import api_schema
from modules.users.models.user_model import User
from modules.vendors.models.vendor_model import Vendor
from modules.auth.vendors.auth_vendor import get_current_vendor
from modules.auth.users.auth_user import get_current_user


router = APIRouter(tags=["API Keys"])

# Create API Key
@router.post("/", response_model=api_schema.APIKeyRead)
def create_api_key(api_key: api_schema.APIKeyCreate, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    return api_service.create_api_key(db, api_key)

# Get all API Keys
@router.get("/", response_model=List[api_schema.APIKeyRead])
def get_api_keys(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    return api_service.get_api_keys(db, current_user.id)

# Get single API Key
@router.get("/{key_id}", response_model=api_schema.APIKeyRead)
def get_api_key(key_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    key = api_service.get_api_key(db, key_id)
    if not key:
        raise HTTPException(status_code=404, detail="API Key not found")
    return key

# Update API Key
@router.put("/{key_id}", response_model=api_schema.APIKeyRead)
def update_api_key(key_id: int, api_key_data: api_schema.APIKeyUpdate, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    key = api_service.update_api_key(db, key_id, api_key_data)
    if not key:
        raise HTTPException(status_code=404, detail="API Key not found")
    return key

# Delete API Key
@router.delete("/{key_id}")
def delete_api_key(key_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    success = api_service.delete_api_key(db, key_id)
    if not success:
        raise HTTPException(status_code=404, detail="API Key not found")
    return {"detail": "API Key deleted successfully"}

# app/routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from db.database import get_db
from modules.auth.admins import auth_admin
from modules.auth.users import auth_user
from modules.auth.vendors import auth_vendor

router = APIRouter(tags=["auth"])

@router.post("/user/token", name="User Login")
def login_user_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    user = auth_user.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = auth_user.create_access_token(data={"sub": user.email})
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/admin/token", name="Admin Login")
def login_admin_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    admin = auth_admin.authenticate_admin(db, form_data.username, form_data.password)
    if not admin:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = auth_admin.create_access_token(data={"sub": admin.email})
    return {"access_token": access_token, "token_type": "bearer"}


@router.post("/vendor/{vendor_domain}/token", name="Vendor Login")
def login_vendor_token(
    vendor_domain: str,
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    vendor = auth_vendor.authenticate_vendor(
    db, form_data.username, form_data.password, vendor_domain
)
    if not vendor:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = auth_vendor.create_access_token(data={"sub": vendor.email, "domain": vendor.domain})
    return {"access_token": access_token, "token_type": "bearer"}

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from uuid import uuid4
from db.database import get_db
from modules.chatbots.schemas.chatbot_schema import ChatbotCreate, ChatbotRead, ChatbotUpdate
from modules.chatbots.services import chatbot_service
from modules.chatbots.models.chatmodel import ChatRequest, ChatResponse
from modules.vendors.models.vendor_model import Vendor
from modules.users.models.user_model import User
from modules.auth.vendors.auth_vendor import get_current_vendor
from modules.auth.users.auth_user import get_current_user


router = APIRouter(tags=["Chatbots"])

@router.post("/", response_model=ChatbotRead)
def create_chatbot(chatbot: ChatbotCreate, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    return chatbot_service.create_chatbot(db, chatbot)

@router.get("/", response_model=List[ChatbotRead])
def get_vendor_chatbots(db: Session = Depends(get_db),  current_vendor: Vendor = Depends(get_current_vendor)):
    return chatbot_service.get_vendor_chatbots(db, current_vendor.id)


@router.get("/", response_model=List[ChatbotRead])
def get_chatbots(db: Session = Depends(get_db)):
    return chatbot_service.get_chatbots(db)

@router.get("/{chatbot_id}", response_model=ChatbotRead)
def get_chatbot(chatbot_id: int, db: Session = Depends(get_db)):
    chatbot = chatbot_service.get_chatbot(db, chatbot_id)
    if not chatbot:
        raise HTTPException(status_code=404, detail="Chatbot not found")
    return chatbot

@router.put("/{chatbot_id}", response_model=ChatbotRead)
def update_chatbot(chatbot_id: int, chatbot_data: ChatbotUpdate, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    chatbot = chatbot_service.update_chatbot(db, chatbot_id, chatbot_data)
    if not chatbot:
        raise HTTPException(status_code=404, detail="Chatbot not found")
    return chatbot

@router.delete("/{chatbot_id}")
def delete_chatbot(chatbot_id: int, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    success = chatbot_service.delete_chatbot(db, chatbot_id)
    if not success:
        raise HTTPException(status_code=404, detail="Chatbot not found")
    return {"detail": "Chatbot deleted successfully"}

@router.post("/{chatbot_id}/ask", response_model=ChatResponse)
def chatbot_interaction_user_singleturn(
    chatbot_id: int,
    request: ChatRequest,
    db: Session = Depends(get_db),
):
    ai_reply = chatbot_service.handle_conversation_singleturn(
        db=db,
        question=request.question,
        chatbot_id=chatbot_id
    )
    return ChatResponse(
    answer=ai_reply.content if hasattr(ai_reply, "content") else str(ai_reply),
    session_id=None
    )

@router.post("/{chatbot_id}/chat", response_model=ChatResponse)
def chatbot_interaction_multiturn(
    chatbot_id: int,
    request: ChatRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    session_id = request.session_id or str(uuid4())

    ai_text = chatbot_service.handle_conversation_multiturn(
        db=db,
        question=request.question,
        chatbot_id=chatbot_id,
        session_id=session_id,
        user_id=current_user.id,
    )

    return ChatResponse(
        answer=ai_text,
        session_id=session_id
    )

#  GLOBAL PUBLIC ANALYTICS
@router.get("/global/top-chatbots")
def global_top_chatbots(
    db: Session = Depends(get_db)
):
    return chatbot_service.get_global_top_chatbots(db)

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.conversations.schemas.conversation_schema import ConversationCreate, ConversationRead
from modules.conversations.services import conversation_service
from modules.users.models.user_model import User
from modules.auth.users.auth_user import get_current_user

router = APIRouter(tags=["Conversations"])

@router.get("/", response_model=List[ConversationRead])
def get_conversations(db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    return conversation_service.get_conversations_with_chatbots(db, current_user.id)

@router.get("/{chatbot_id}", response_model=List[ConversationRead])
def get_conversation(chatbot_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    conv = conversation_service.get_conversations_with_a_chatbot(db, current_user.id, chatbot_id)
    if not conv:
        raise HTTPException(status_code=404, detail="Conversation not found")
    return conv


@router.delete("/{conversation_id}")
def delete_conversation(conversation_id: int, db: Session = Depends(get_db), current_user: User = Depends(get_current_user)):
    success = conversation_service.delete_conversation(db, conversation_id)
    if not success:
        raise HTTPException(status_code=404, detail="Conversation not found")
    return {"detail": "Conversation deleted successfully"}


from fastapi import APIRouter, UploadFile, File, Form, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.documents.schemas.document_schema import DocumentCreate, DocumentRead
from modules.documents.services import document_service
from modules.vendors.models.vendor_model import Vendor
from modules.auth.vendors.auth_vendor import get_current_vendor

router = APIRouter(tags=["Documents"])

@router.post("/preview", response_model=DocumentCreate)
def preview_document(
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(get_current_vendor),
    file: UploadFile = File(...),
    vendor_id: int = Form(...),
    chatbot_id: int = Form(...)
):
   
    return document_service.add_document(db,  file, vendor_id, chatbot_id)


@router.post("/add", response_model=DocumentRead)
def save_document_endpoint(
    title: str = Form(...),
    summary: str = Form(...),
    tags: str = Form(...),
    file: UploadFile = File(...),
    vendor_id: int = Form(...),
    chatbot_id: int = Form(...),
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(get_current_vendor)
):
    return document_service.save_document(db, vendor_id, chatbot_id, title, summary, tags, file)


@router.get("/", response_model=List[DocumentRead])
def get_documents(db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    return document_service.get_documents(db)

@router.get("/{document_id}", response_model=DocumentRead)
def get_document(document_id: int, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    document = document_service.get_document(db, document_id)
    if not document:
        raise HTTPException(status_code=404, detail="Document not found")
    return document

@router.put("/{document_id}", response_model=DocumentRead)
def update_document(document_id: int, document_data: DocumentCreate, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    document = document_service.update_document(db, document_id, document_data)
    if not document:
        raise HTTPException(status_code=404, detail="Document not found")
    return document

@router.delete("/{document_id}")
def delete_document(document_id: int, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    success = document_service.delete_document(db, document_id)
    if not success:
        raise HTTPException(status_code=404, detail="Document not found")
    return {"detail": "Document deleted successfully"}

@router.post("/{document_id}/knowledge-base")
def create_knowledgebase(document_id: int, db: Session = Depends(get_db), current_vendor: Vendor = Depends(get_current_vendor)):
    try:
        vectordb = document_service.embed_document(db, document_id)
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to embed document: {str(e)}")

    return {
        "document_id": document_id,
        "vector_db_type": vectordb.__class__.__name__,
        "message": "Document embedding completed successfully"
    }

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.embeddings.schemas.embedding_schema import EmbeddingCreate, EmbeddingRead, EmbeddingUpdate
from modules.embeddings.services import embedding_service
from modules.admins.models.admin_model import Admin
from modules.auth.admins.auth_admin import get_current_admin

router = APIRouter(tags=["Embeddings"])

@router.post("/create", response_model=EmbeddingRead)
def add_embedding(data: EmbeddingCreate, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    return embedding_service.add_embedding(db, data)

@router.get("/", response_model=List[EmbeddingRead])
def get_embeddings(db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    return embedding_service.get_embeddings(db)

@router.get("/{embedding_id}", response_model=EmbeddingRead)
def get_embedding(embedding_id: int, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    embed = embedding_service.get_embedding(db, embedding_id)
    if not embed:
        raise HTTPException(status_code=404, detail="Embedding not found")
    return embed

@router.put("/update/{embedding_id}", response_model=EmbeddingRead)
def update_embedding(embedding_id: int, embed_data: EmbeddingUpdate, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    embed = embedding_service.update_embedding(db, embedding_id, embed_data)
    if not embed:
        raise HTTPException(status_code=404, detail="Embedding not found")
    return embed

@router.delete("/delete/{embedding_id}")
def delete_embedding(embedding_id: int, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    success = embedding_service.delete_embedding(db, embedding_id)
    if not success:
        raise HTTPException(status_code=404, detail="Embedding not found")
    return {"detail": "Embedding deleted successfully"}

# modules/llms/llm_router.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.llms.schemas.llm_schema import LLMCreate, LLMRead, LLMUpdate
from modules.llms.services import llm_service
from modules.admins.models.admin_model import Admin
from modules.auth.admins.auth_admin import get_current_admin

router = APIRouter(tags=["LLMs"])


@router.post("/", response_model=LLMRead)
def create_llm(data: LLMCreate, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    return llm_service.create_llm(db, data)


@router.get("/", response_model=List[LLMRead])
def list_llms(db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    return llm_service.get_llms(db)


@router.get("/{llm_id}", response_model=LLMRead)
def get_llm(llm_id: int, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    llm = llm_service.get_llm(db, llm_id)
    if not llm:
        raise HTTPException(status_code=404, detail="LLM not found")
    return llm


@router.put("/{llm_id}", response_model=LLMRead)
def update_llm(llm_id: int, llm_data: LLMUpdate, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    llm = llm_service.update_llm(db, llm_id, llm_data)
    if not llm:
        raise HTTPException(status_code=404, detail="LLM not found")
    return llm


@router.delete("/{llm_id}")
def delete_llm(llm_id: int, db: Session = Depends(get_db), current_admin: Admin = Depends(get_current_admin)):
    success = llm_service.delete_llm(db, llm_id)
    if not success:
        raise HTTPException(status_code=404, detail="LLM not found")
    return {"detail": "LLM deleted successfully"}

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.auth.vendors import auth_vendor
from modules.users.schemas.user_schema import UserCreate, UserRead, UserUpdate
from modules.users.services import user_service
from modules.users.models.user_model import User
from modules.auth.users import auth_user
from modules.vendors.models.vendor_model import Vendor

router = APIRouter(tags=["Users"])

@router.post("/create", response_model=UserRead)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    new_user = user_service.create_user(db, user)
    if not new_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    return new_user

@router.get("/{user_id}", response_model=UserRead)
def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(auth_user.get_current_user)
):
    user = user_service.get_user(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@router.get("/", response_model=List[UserRead])
def get_users(
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return user_service.get_users_by_vendor(db, current_vendor.id)
    

@router.put("/update/{user_id}", response_model=UserRead)
def update_user(
    user_id: int,
    user_data: UserUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(auth_user.get_current_user)
):
    updated_user = user_service.update_user(db, user_id, user_data)
    if not updated_user:
        raise HTTPException(status_code=404, detail="User not found")
    return updated_user

@router.delete("/{user_id}")
def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(auth_user.get_current_user)
):
    success = user_service.delete_user(db, user_id)
    if not success:
        raise HTTPException(status_code=404, detail="User not found")
    return {"detail": "User deleted successfully"}

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List
from db.database import get_db
from modules.vendors.schemas.vendor_schema import VendorCreate, VendorRead, VendorUpdate
from modules.vendors.services import vendor_service
from modules.vendors.models.vendor_model import Vendor
from modules.auth.vendors import auth_vendor
from modules.vendors.models.vendor_model import Vendor


router = APIRouter(tags=["Vendors"])

@router.post("/create", response_model=VendorRead)
def create_vendor(vendor: VendorCreate, db: Session = Depends(get_db)):
    new_vendor = vendor_service.create_vendor(db, vendor)
    if not new_vendor:
        raise HTTPException(status_code=400, detail="Email already registered")
    return new_vendor

@router.get("/all-vendors", response_model=List[VendorRead])
def list_vendors(db: Session = Depends(get_db)):
    return vendor_service.list_vendors(db)

@router.get("/{vendor_id}", response_model=VendorRead)
def get_vendor(vendor_id: int, db: Session = Depends(get_db)):
    vendor = vendor_service.get_vendor(db, vendor_id)
    if not vendor:
        raise HTTPException(status_code=404, detail="Vendor not found")
    return vendor

@router.put("/update/{vendor_id}", response_model=VendorRead)
def update_vendor(
    vendor_id: int,
    vendor_data: VendorUpdate,
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    updated_vendor = vendor_service.update_vendor(db, vendor_id, vendor_data)
    if not updated_vendor:
        raise HTTPException(status_code=404, detail="Vendor not found")
    return updated_vendor

@router.get("/top-chatbots/messages")
def vendor_top_chatbots_by_messages(
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return vendor_service.get_vendor_top_chatbots_by_messages(db, current_vendor.id)


@router.get("/top-chatbots/users")
def vendor_top_chatbots_by_unique_users(
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return vendor_service.get_vendor_top_chatbots_by_users(db, current_vendor.id)


# ------------------------------
# Vendor 7-Day Charts
# ------------------------------

@router.get("/daily/messages")
def vendor_daily_messages(
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return vendor_service.get_vendor_daily_message_count(db, current_vendor.id)


@router.get("/daily/unique-users")
def vendor_daily_unique_users(
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return vendor_service.get_vendor_daily_unique_users(db, current_vendor.id)


# ------------------------------
# User-Specific Token Usage
# ------------------------------

@router.get("/user/{user_id}/tokens-last7")
def vendor_user_tokens_last7(
    user_id: int,
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return {
        "user_id": user_id,
        "tokens_last_7_days": vendor_service.get_user_tokens_last_7_days_for_vendor(
            db, current_vendor.id, user_id
        )
    }


@router.get("/user/{user_id}/tokens-total")
def vendor_user_tokens_total(
    user_id: int,
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return {
        "user_id": user_id,
        "total_tokens": vendor_service.get_user_total_tokens_for_vendor(
            db, current_vendor.id, user_id
        )
    }


@router.get("/user/{user_id}/chatbot/{chatbot_id}/messages-count")
def vendor_user_chatbot_message_count(
    user_id: int,
    chatbot_id: int,
    db: Session = Depends(get_db),
    current_vendor: Vendor = Depends(auth_vendor.get_current_vendor)
):
    return {
        "user_id": user_id,
        "chatbot_id": chatbot_id,
        "message_count": vendor_service.get_user_message_count_for_chatbot_and_vendor(
            db, current_vendor.id, user_id, chatbot_id
        )
    }



